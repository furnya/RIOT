#include "periph/gpio.h"
#include "periph/adc.h"
#include "xtimer.h"
#include "hdc1000.h"
#include "hdc1000_params.h"
#include "tsl4531x.h"
#include "tsl4531x_params.h"
#include "ds18.h"
#include "ds18_params.h"

#include "app.h"

#define RES                 ADC_RES_10BIT
#define GLOBAL_STARTUP_TIME (5)

#define ENABLE_DEBUG        (1)
#include "debug.h"

typedef struct {
    adc_t read_pin;
} hygrometer_params_t;

typedef struct {
    const hygrometer_params_t* params;
} hygrometer_t;



typedef struct {
    /* TODO: deduplicate raw_data and data_type. maybe a pointer to a data_t?
     * Or maybe main.c just needs to have knowledge of sensor_t, or something.
     * Remember the encapsulation
     * within s_and_a.c, though. Maybe I need an s_and_a_read() function or the
     * like. */
    const char* name;
    int16_t raw_data;
    data_type_te data_type;
    sensor_type_te sensor_type;
    uint8_t config_no;
    void* dev;
} sensor_t;

static hdc1000_t hdc1000_dev;
static tsl4531x_t tsl4531x_dev;
static ds18_t ds18_dev;
static hygrometer_t hygrometer_1_dev;
static hygrometer_t hygrometer_2_dev;
static hygrometer_t hygrometer_3_dev;
static hygrometer_t hygrometer_4_dev;

static sensor_t sensors[] =
{
    {
        .name = "hdc1000 temp",
        .raw_data = 0,
        .data_type = SENSOR_DATA_T_TEMP,
        .sensor_type = SENSOR_T_HDC1000_TEMP,
        .config_no = 0,
        .dev = &hdc1000_dev
    },
    {
        .name = "hdc1000 hum",
        .raw_data = 0,
        .data_type = SENSOR_DATA_T_HUM,
        .sensor_type = SENSOR_T_HDC1000_HUM,
        .config_no = 0,
        .dev = &hdc1000_dev
    },
    {
        .name = "tsl4531x",
        .raw_data = 0,
        .data_type = SENSOR_DATA_T_UINT16,
        .sensor_type = SENSOR_T_TSL4531X,
        .config_no = 0,
        .dev = &tsl4531x_dev
    },
    {
        .name = "ds18",
        .raw_data = 0,
        .data_type = SENSOR_DATA_T_TEMP,
        .sensor_type = SENSOR_T_DS18,
        .config_no = 0,
        .dev = &ds18_dev
    },
    {
        .name = "hygrometer 1",
        .raw_data = 0,
        .data_type = SENSOR_DATA_T_UINT16,
        .sensor_type = SENSOR_T_HYGROMETER,
        .config_no = 0,
        .dev = &hygrometer_1_dev
    },
    {
        .name = "hygrometer 2",
        .raw_data = 0,
        .data_type = SENSOR_DATA_T_UINT16,
        .sensor_type = SENSOR_T_HYGROMETER,
        .config_no = 1,
        .dev = &hygrometer_2_dev
    },
    {
        .name = "hygrometer 3",
        .raw_data = 0,
        .data_type = SENSOR_DATA_T_UINT16,
        .sensor_type = SENSOR_T_HYGROMETER,
        .config_no = 2,
        .dev = &hygrometer_3_dev
    },
    {
        .name = "hygrometer 4",
        .raw_data = 0,
        .data_type = SENSOR_DATA_T_UINT16,
        .sensor_type = SENSOR_T_HYGROMETER,
        .config_no = 3,
        .dev = &hygrometer_4_dev
    },
};

#define SENSOR_NUMOF           sizeof(sensors) / sizeof(sensors[0])

int16_t hygrometer_read(hygrometer_t* dev, int16_t* val)
{
    return (int16_t)adc_sample(dev->params->read_pin, RES);
}

int hygrometer_init(hygrometer_t* dev, const hygrometer_params_t* params)
{
    int ret;

    DEBUG("[sens] init hygromter %i\n", (int)params->pin);

    if ((ret = adc_init(params->read_pin)) < 0) {
        return ret;
    }

    dev->params = params;

    return 0;
}

// void s_and_a_water(valve_t* valve)
// {

//     int moisture_level = 0;

//     if (!valve->control_sensor) {
//         for (uint8_t i = 0; i < SENSOR_NUMOF; i++) {
//             moisture_level += sensors[i].raw_data;
//         }
//         moisture_level = moisture_level / SENSOR_NUMOF;
//     }
//     else {
//         moisture_level = valve->control_sensor->raw_data;
//     }

//     if ((moisture_level > valve->watering_level) &&
//          _valve_safety_test(valve, moisture_level)) {

//         gpio_set(valve->control_pin);
//         xtimer_sleep(valve->watering_time);
//         gpio_clear(valve->control_pin);
//     }

// }

void s_and_a_sensor_update(sensor_t* sensor)
{
    /* TODO: my sensor_t looks a bit like a dev_t. Can I replace
     * this by essentially writing a driver in typical RIOT format for the ones
     * that aren't merged?
     */

    /* TODO: put failure tests around these in case any data reading fails */
    switch ( sensor->sensor_type ) {
        case SENSOR_T_HDC1000_TEMP:
            hdc1000_read_cached((const hdc1000_t *)sensor->dev, &(sensor->raw_data), NULL);
            break;

        case SENSOR_T_HDC1000_HUM:
            hdc1000_read_cached((const hdc1000_t *)sensor->dev, NULL, &(sensor->raw_data));
            break;

        case SENSOR_T_TSL4531X:
            sensor->raw_data = tsl4531x_simple_read(sensor->dev);
            break;

        case SENSOR_T_DS18:

            // DEBUG_PRINT("2.1\n");
            ds18_get_temperature(sensor->dev, &(sensor->raw_data));
            break;

        case SENSOR_T_HYGROMETER:
            sensor->raw_data = hygrometer_read(sensor->dev);
            break;

        default:
            break;
    }
}

void s_and_a_hardware_test(void)
{
    /* Test the power line for the moisture sensors */
    puts("Testing moisture sensor power lines. Light on control boards should be blinking on and off.");
    for (int i = 0; i < 5; i++) {
        gpio_set(SENSOR_POWER_PIN);
        xtimer_sleep(1);
        gpio_clear(SENSOR_POWER_PIN);
        xtimer_sleep(1);
    }

    /* Leave the power on for the rest of the test. */
    gpio_set(SENSOR_POWER_PIN);

    /* Test the valves */
    // puts("Testing the valves. Valves should click on and off three times each.");
    // for (uint8_t i = 0; i < VALVE_NUMOF; i++) {
    //     for (int j = 0; j < 3; j++) {
    //         gpio_set(valves[i].control_pin);
    //         xtimer_sleep(1);
    //         gpio_clear(valves[i].control_pin);
    //         xtimer_sleep(1);
    //     }
    // }

    /* Test the sensors */
    puts("Testing the sensors. Check the readings are sensible.");
    for (uint8_t i = 0; i < SENSOR_NUMOF; i++) {
        s_and_a_sensor_update(&sensors[i]);

        float cents = (float)sensors[i].raw_data/100;
        switch ( sensors[i].data_type ) {
            case SENSOR_DATA_T_TEMP:
            case SENSOR_DATA_T_HUM:
                printf("%s: %.2f\n", sensors[i].name, cents);
                break;
            case SENSOR_DATA_T_UINT16:
                printf("%s: %d\n", sensors[i].name, sensors[i].raw_data);
                break;

            default:
                break;
        }
    }

    gpio_clear(SENSOR_POWER_PIN);

    puts("Hardware test complete.");
}

// int s_and_a_valve_init(valve_t* valve)
// {
//     return gpio_init(valve->control_pin, GPIO_OUT);
// }

int s_and_a_sensor_init(sensor_t* sensor, data_t* data)
{
    assert(sensor);
    assert(data);

    int ret;

    switch ( sensor->sensor_type ) {
        case SENSOR_T_HDC1000_TEMP:
            ret = hdc1000_init(sensor->dev, &hdc1000_params[sensor->config_no]);
            break;

            /* TODO: currently the HDC1000 gets initialised twice, because it's
             * got two readings, not because it's two devices. How to do this
             * better? Also handle params[1], [2] etc.
             *
             * These issues might be better to be addressed when figuring out
             * how to make this application extensible to any possible sensor
             * (that's supported in RIOT), without the user having to touch the
             * code.
             *
             */

        case SENSOR_T_HDC1000_HUM:
            ret = hdc1000_init(sensor->dev, &hdc1000_params[sensor->config_no]);
            break;

        case SENSOR_T_TSL4531X:
            ret = tsl4531x_init(sensor->dev, &tsl4531x_params[sensor->config_no]);
            break;

        case SENSOR_T_DS18:
            ret = ds18_init(sensor->dev, &ds18_params[sensor->config_no]);
            break;

        case SENSOR_T_HYGROMETER:
            ret = hygrometer_init(sensor->dev, &hygrometer_params[sensor->config_no]);
            break;

        default:
            ret = -1;
            break;
    }

    data->type = sensor->data_type;

    return ret;
}

void s_and_a_update_all(data_t* data)
{
    gpio_set(SENSOR_POWER_PIN);
    xtimer_sleep(GLOBAL_STARTUP_TIME);

    /* Collect data from sensors */
    for (uint8_t i = 0; i < SENSOR_NUMOF; i++) {
        // DEBUG_PRINT("1\n");
        assert(data + i);
        // DEBUG_PRINT("2\n");
        s_and_a_sensor_update(&sensors[i]);
        // DEBUG_PRINT("3\n");
        (data + i)->raw = sensors[i].raw_data;
        DEBUG_PRINT("Sensor %d, raw data %d\n", i, (data + i)->raw);
    }

    gpio_clear(SENSOR_POWER_PIN);
}

void s_and_a_init_all(data_t* data)
{
    int ret;

    if ((ret = gpio_init(SENSOR_POWER_PIN, GPIO_OUT)) < 0) {
        printf("Couldn't initialise global power pin: %d\n", ret);
    }
    gpio_clear(SENSOR_POWER_PIN);

    for (uint8_t i = 0; i < SENSOR_NUMOF; i++) {
        if ((ret = s_and_a_sensor_init(&sensors[i], data + i)) < 0) {
            printf("Couldn't initialise sensor %d: %d\n", i, ret);
        }
    }
}
